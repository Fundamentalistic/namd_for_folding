#include "charm++.h"
#include "CollectionMaster.decl.h"
#include "CollectionMaster.h"
#include "InfoStream.h"
#include "Node.h"
#include "Output.h"
#include "ProcessorPrivate.h"

// #define DEBUGM
#include "Debug.h"

CollectionMaster::CollectionMaster()
{
  if (CpvAccess(CollectionMaster_instance) == 0) {
    CpvAccess(CollectionMaster_instance) = this;
  } else {
    DebugM(1, "CollectionMaster::CollectionMaster() - another instance of CollectionMaster exists!\n");
  }
}


CollectionMaster::~CollectionMaster(void)
{
}


void CollectionMaster::receivePositions(CollectVectorMsg *msg)
{
  positions.submitData(msg->seq,msg->aid,msg->data);
  delete msg;

  CollectVectorInstance *c;
  while ( c = positions.removeReady() ) { disposePositions(c); }
}

void CollectionMaster::enqueuePositions(int seq)
{
  positions.enqueue(seq);

  CollectVectorInstance *c;
  while ( c = positions.removeReady() ) { disposePositions(c); }
}

void CollectionMaster::disposePositions(CollectVectorInstance *c)
{
    DebugM(3,"Collected positions at " << c->seq << endl);
    int seq = c->seq;
    int size = c->data.size();
    Vector *data = c->data.begin();
    Node::Object()->output->coordinate(seq,size,data);
    delete c;
}


void CollectionMaster::receiveVelocities(CollectVectorMsg *msg)
{
  velocities.submitData(msg->seq,msg->aid,msg->data);
  delete msg;

  CollectVectorInstance *c;
  while ( c = velocities.removeReady() ) { disposeVelocities(c); }
}

void CollectionMaster::enqueueVelocities(int seq)
{
  velocities.enqueue(seq);

  CollectVectorInstance *c;
  while ( c = velocities.removeReady() ) { disposeVelocities(c); }
}

void CollectionMaster::disposeVelocities(CollectVectorInstance *c)
{
    DebugM(3,"Collected velocities at " << c->seq << endl);
    int seq = c->seq;
    int size = c->data.size();
    Vector *data = c->data.begin();
    Node::Object()->output->velocity(seq,size,data);
    delete c;
}


void CollectionMaster::receiveForces(CollectVectorMsg *msg)
{
  forces.submitData(msg->seq,msg->aid,msg->data);
  delete msg;

  CollectVectorInstance *c;
  while ( c = forces.removeReady() ) { disposeForces(c); }
}

void CollectionMaster::enqueueForces(int seq)
{
  forces.enqueue(seq);

  CollectVectorInstance *c;
  while ( c = forces.removeReady() ) { disposeForces(c); }
}

void CollectionMaster::disposeForces(CollectVectorInstance *c)
{
    DebugM(3,"Collected forces at " << c->seq << endl);
    int seq = c->seq;
    int size = c->data.size();
    Vector *data = c->data.begin();
    Node::Object()->output->all_force(seq,size,data);
    delete c;
}


void * CollectVectorMsg::pack(CollectVectorMsg *msg)
{
  int length = sizeof(int) + sizeof(int) +
		msg->aid.size() * sizeof(AtomID) +
		msg->data.size() * sizeof(Vector);
  char *buffer = (char*)CkAllocBuffer(msg,length);
  char *b = buffer;
  memcpy(b, &(msg->seq), sizeof(int)); b += sizeof(int);
  int size = msg->aid.size(); memcpy(b, &size, sizeof(int)); b += sizeof(int);
  memcpy(b, msg->aid.begin(), size*sizeof(AtomID)); b += size*sizeof(AtomID);
  memcpy(b, msg->data.begin(), size*sizeof(Vector)); b += size*sizeof(Vector);
  delete msg;
  return buffer;
}


CollectVectorMsg* CollectVectorMsg::unpack(void *ptr)
{
  void *_ptr = CkAllocBuffer(ptr, sizeof(CollectVectorMsg));
  CollectVectorMsg* m = new (_ptr) CollectVectorMsg;
  char *b = (char*)ptr;
  memcpy(&(m->seq), b, sizeof(int)); b += sizeof(int);
  int size; memcpy(&size, b, sizeof(int)); b += sizeof(int);
  m->aid.resize(size);
  memcpy(m->aid.begin(), b, size*sizeof(AtomID)); b += size*sizeof(AtomID);
  m->data.resize(size);
  memcpy(m->data.begin(), b, size*sizeof(Vector)); b += size*sizeof(Vector);
  CkFreeMsg(ptr);
  return m;
}


#include "CollectionMaster.def.h"


/***************************************************************************
 * RCS INFORMATION:
 *
 *	$RCSfile $
 *	$Author $	$Locker:  $		$State: Exp $
 *	$Revision: 1.1018 $	$Date: 1999/05/14 21:32:46 $
 *
 ***************************************************************************
 * REVISION HISTORY:
 *
 * $Log: CollectionMaster.C,v $
 * Revision 1.1018  1999/05/14 21:32:46  jim
 * Fixed bugs which could stall output queue.
 *
 * Revision 1.1017  1999/05/11 23:56:14  brunner
 * Changes for new charm version
 *
 * Revision 1.1016  1999/01/18 21:53:55  brunner
 * Changes to deal with recent Charm++ changes.  More extensive changes
 * may be needed soon, but this works for now.
 *
 * Revision 1.1015  1998/10/24 19:57:19  jim
 * Eliminated warnings generated by g++ -Wall.
 *
 * Revision 1.1014  1998/09/14 16:11:33  jim
 * Changes to reduce node 0 memory use.  Fixed bug in ResizeArray::item().
 *
 * Revision 1.1013  1998/02/26 01:51:23  milind
 * Fixed bugs in CollectionMaster and ReductionManager that were causing
 * crash on Origin2000.
 *
 * Revision 1.1012  1997/12/19 23:42:38  jim
 * Replaced assignments with memcpys and reordered memcpys for efficiency.
 *
 * Revision 1.1011  1997/12/10 17:53:33  milind
 * Removed the dcd file already exists error. Now, if a dcd file already exists,
 * it is moved to a .bak before writing new dcd file.
 *
 * Revision 1.1010  1997/12/02 22:04:00  milind
 * Fixed a silly bug that accessed memory after it was freed.
 *
 * Revision 1.1009  1997/11/07 20:17:33  milind
 * Made NAMD to run on shared memory machines.
 *
 * Revision 1.1008  1997/04/04 23:34:13  milind
 * Got NAMD2 to run on Origin2000.
 * Included definitions of class static variables in C files.
 * Fixed alignment bugs by using memcpy instead of assignment in
 * pack and unpack.
 *
 * Revision 1.1007  1997/03/19 11:53:56  ari
 * Add Broadcast mechanism.
 * Fixed RCS Log entries on files that did not have Log entries.
 * Added some register variables to Molecule and ComputeNonbondedExcl.C
 *
 *
 ***************************************************************************/
