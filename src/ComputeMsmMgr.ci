/**
***  Copyright (c) 1995, 1996, 1997, 1998, 1999, 2000 by
***  The Board of Trustees of the University of Illinois.
***  All rights reserved.
**/

module ComputeMsmMgr {

  message MsmInitMsg;

/*
  // variable size message
  message GridFloatMsg {
    float gdata[];
  };
*/

  // fixed size message 
  message GridFloatMsg;

  // fixed size message 
  message GridC1VectorMsg;

  message MsmBlockProxyMsg {
    char msmBlockProxyData[];
  };

  message MsmGridCutoffProxyMsg {
    char msmGridCutoffProxyData[];
  };

  message MsmGridCutoffInitMsg;

  group ComputeMsmMgr {
    entry ComputeMsmMgr(void);
    entry void initialize(MsmInitMsg *);
    entry void recvMsmBlockProxy(MsmBlockProxyMsg *);
    entry void recvMsmGridCutoffProxy(MsmGridCutoffProxyMsg *);
    entry void update(CkQdMsg *);
    entry void addPotential(GridFloatMsg *);
  };

  group MsmBlockMap : CkArrayMap {
    entry MsmBlockMap(int level);
  };

  array [3D] MsmBlock {
    entry MsmBlock(int level);
    entry void addCharge(GridFloatMsg *);
    entry void addPotential(GridFloatMsg *);
  };

  group MsmGridCutoffMap : CkArrayMap {
    entry MsmGridCutoffMap(void);
  };

  // MsmGridCutoff calculates a charge -> potential interaction pair
  // between blocks.
  array [1D] MsmGridCutoff {
    entry MsmGridCutoff(void);

    // initialize() passes in the block index and range for potentials
    entry void initialize(MsmGridCutoffInitMsg *);

    // compute() passes in the charge block
    entry void compute(GridFloatMsg *);
  };

  chare MsmTimer {
    entry MsmTimer(void);
    entry [reductiontarget] void done(double tm[n], int n);
  };

  chare MsmProfiler {
    entry MsmProfiler(void);
    entry [reductiontarget] void done(int tm[n], int n);
  };

};
